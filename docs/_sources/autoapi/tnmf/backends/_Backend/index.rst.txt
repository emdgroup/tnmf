:orphan:

:mod:`tnmf.backends._Backend`
=============================

.. py:module:: tnmf.backends._Backend

.. autoapi-nested-parse::

   A module that defines a common interface for all backends.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   tnmf.backends._Backend.Backend




Attributes
~~~~~~~~~~

.. autoapisummary::

   tnmf.backends._Backend.sliceNone


.. data:: sliceNone
   

   

.. class:: Backend(reconstruction_mode: str = 'valid')


   Bases: :py:obj:`abc.ABC`

   The base class for all backends.

   It exists to define a generic functional interface that is shared by all backends through inheritance, which allows a
   clear separation between algorithmic steps and their actual numerical implementation.

   Some common functionality between all backends is already defined inside this class but can be overridden if necessary.

   .. method:: initialize(self, V: numpy.ndarray, atom_shape: Tuple[int, Ellipsis], n_atoms: int, W: Optional[numpy.ndarray] = None, axes_W_normalization: Optional[Union[int, Tuple[int, Ellipsis]]] = None) -> Tuple[numpy.ndarray, numpy.ndarray]


   .. method:: to_ndarray(arr) -> numpy.ndarray
      :staticmethod:
      :abstractmethod:


   .. method:: normalize(arr: numpy.ndarray, axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None)
      :staticmethod:


   .. method:: convolve_multi_1d(arr: numpy.ndarray, kernels: Tuple[numpy.ndarray, Ellipsis], axes: Tuple[int, Ellipsis]) -> numpy.ndarray
      :staticmethod:
      :abstractmethod:


   .. method:: reconstruction_gradient_W(self, V: numpy.ndarray, W: numpy.ndarray, H: numpy.ndarray, s: slice = sliceNone) -> Tuple[numpy.ndarray, numpy.ndarray]
      :abstractmethod:


   .. method:: reconstruction_gradient_H(self, V: numpy.ndarray, W: numpy.ndarray, H: numpy.ndarray, s: slice = sliceNone) -> Tuple[numpy.ndarray, numpy.ndarray]
      :abstractmethod:


   .. method:: reconstruct(self, W: numpy.ndarray, H: numpy.ndarray) -> numpy.ndarray
      :abstractmethod:


   .. method:: partial_reconstruct(self, W: numpy.ndarray, H: numpy.ndarray, i_atom: int) -> numpy.ndarray


   .. method:: reconstruction_energy(self, V: numpy.ndarray, W: numpy.ndarray, H: numpy.ndarray) -> float



